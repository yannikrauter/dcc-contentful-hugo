// const { src, dest, parallel, series, watch } = require("gulp");
// var exec = require("child_process").exec;
// var fs = require("file-system");
// var del = require("del");
import gulp from "gulp";
const { src, dest, series, parallel, task } = gulp;
import { exec } from "node:child_process";
import { deleteAsync } from "del";
import { fs } from "file-system";

// Contentful uses 21 or 22 characters for randomly genarated IDs
const lengthOfPersonId = 21;

// Defines which roles for persons will be listed as "Speakers" in the navigation
var speakerRoles = ["speaker", "keynote-speaker"];

// Paths for file manipulation
var pathToRoles = "./content/role/";
var pathToPersons = "./content/person/";

/*
  * Please note:
  * contentful-ssg also cleans the "content" directory in the same way.
  * However, its implementation only works on Unix, but not on Windows.
  * Therefore, the same cleanup is also performed by gulp as a redundancy.
  * 
  * Important:
  * The content-pattern should mirror the one in ".gitignore"!
  * However, here it is relative and therefore includes a leading `.`.
  * For more information, please read the description of
  * the clean()-function or the description in the ".gitignore".
*/
var pathsToDelete = {
  content: "./content/*/[a-zA-Z0-9]*",
  public: "./public/**/*"
}

/*
  * Define the paths to clean up the repository when resetting it to its
  * original/default state (similar to a fresh clone).
*/
var pathsToDeleteResetRepository = {
  publicDirectory: "./public",
  resourcesDirectory: "./resources",
  hugoBuildLock: "./.hugo_build.lock",
  packageLock: "./package-lock.json",
  nodeModulesDirectory: "./node_modules"
}


/*
  * Runs a single shell command, printing the output.
*/
function runShellCommand(command) {
  return exec(command, (error, stdout, stderr) => {
    if (error) {
      console.error(error);
    }
  }).stdout.on("data", function(data) {
    process.stdout.write(data); // Use this instead of console.log to prevent inserting new lines 
  });
}


/*
  * Prints information about important prerequisites to the console.
*/
function prerequisites(cb) {
  console.log("Important: Hugo must be installed in order for the build step to succeed!");
  cb(); // Signal async completion to gulp - triggers error if removed
}
prerequisites.description = "Print information about important prerequisites.";


/*
  * Removes any files in the "public" directory as well as all the
  * content-files (which are typically fetched from the CMS) within the
  * "content" directory (excluding however those called _index.md and those
  * at the root of the "content" directory, like impressum.md).
*/
function clean() {
  return deleteAsync([
    pathsToDelete.content,
    pathsToDelete.public
  ]);
}
clean.description = "Remove files generated by contentful-ssg and Hugo.";

/*
  * Removes any files that are generated only after cloning the repository
  * (e.g. through using commands such as "npm install" or "npx gulp"),
  * thereby resetting the repository to its original/default state
  * (similar to a fresh clone).
*/
function cleanResetRepository() {
  return deleteAsync([
    pathsToDeleteResetRepository.publicDirectory,
    pathsToDeleteResetRepository.resourcesDirectory,
    pathsToDeleteResetRepository.hugoBuildLock,
    pathsToDeleteResetRepository.packageLock,
    pathsToDeleteResetRepository.nodeModulesDirectory
  ]);
}
cleanResetRepository.description = "Remove files generated by Node and gulp.";

/*
  * For a provided path, prints a list of those files which would have been deleted.
  * Only used for debugging.
*/
async function previewClean(path) {
  var deletedPaths = await deleteAsync([path], {dryRun: true});
  console.log("These paths would have been deleted:\n", deletedPaths.join("\n"));
}


/*
  * Fetches all content-files from Contentful using contenful-ssg.
*/
function fetch() {
  return runShellCommand("npx cssg fetch -v");
}
fetch.description = "Fetch all content from Contentful.";


/*
  * Post-processes the content-files after fetching.
  * Modifies the configuration of navigation items to list those persons
  * which have certain roles as "Speakers" in the navigation.
  * 
  * 2-step process:
  *   - Filter all roles for speaker-roles and find the ids of their linked persons.
  *   - Filter all persons using those ids and replace their configured
  *     navigation parent to list them as "Speakers".
*/
function postprocess(cb) {

  var idsOfPersonsWithSpeakerRoles = getIdsOfPersonsWithSpeakerRoles();
  replaceMenuEntryForPersonsWithSpeakerRoles(idsOfPersonsWithSpeakerRoles);
  cb(); // Signal async completion to gulp - triggers error if removed
}
postprocess.description = "Post-processing for listing speakers in navigation.";


/*
  * Filter all roles for speaker-roles and find the ids of their linked persons.
*/
function getIdsOfPersonsWithSpeakerRoles() {

  var idsOfPersonsWithSpeakerRoles = [];

  var namesOfRoleFiles = fs.readdirSync(pathToRoles);
  var stringToRecognizePersonId = "person:\n  id: ";
  var lengthOfStringToRecognizePersonId = stringToRecognizePersonId.length;

  for (var index in namesOfRoleFiles) {
    var nameOfCurrentRoleFile = namesOfRoleFiles[index];
    var role = nameOfCurrentRoleFile.split("_")[0];

    // Check if role is a speaker-role (to prevent returning incorrect person ids)
    if (speakerRoles.includes(role)) {
      var roleFileContent = fs.readFileSync(pathToRoles + nameOfCurrentRoleFile, "utf8");

      var startingIndexOfPersonId =
        roleFileContent.indexOf(stringToRecognizePersonId) + lengthOfStringToRecognizePersonId;
      var endingIndexOfPersonId = startingIndexOfPersonId + lengthOfPersonId;

      var personId = roleFileContent.substring(startingIndexOfPersonId, endingIndexOfPersonId);
      idsOfPersonsWithSpeakerRoles.push(personId);
    }
  }

  return idsOfPersonsWithSpeakerRoles;
}


/*
  * Filter all persons using provided ids and replace their configured
  * navigation parent to list them as "Speakers".
*/
function replaceMenuEntryForPersonsWithSpeakerRoles(idsOfPersonsWithSpeakerRoles) {

  var namesOfPersonFiles = fs.readdirSync(pathToPersons);
  
  var stringToRecognizeMenuEntry = "menu:\n  main:\n    parent: person";
  var stringToReplaceMenuEntry = "menu:\n  main:\n    parent: speaker";

  var stringToRecognizePersonId = "defaultMetaFields:\n  sys:\n    id: ";
  var lengthOfStringToRecognizePersonId = stringToRecognizePersonId.length;

  for (var index in namesOfPersonFiles) {
    var nameOfCurrentPersonFile = namesOfPersonFiles[index];
    var fileEndingIndex = nameOfCurrentPersonFile.lastIndexOf(".md");
    
    // Check if file ending is correct (to prevent processing irrelevant files)
    if (fileEndingIndex > 0) {
      var personFilePath = pathToPersons + nameOfCurrentPersonFile;
      var personFileContent = fs.readFileSync(personFilePath, "utf8");

      // Check if the file is an entry in the menu (to prevent processing irrelevant files)
      var startingIndexOfPersonId = personFileContent.indexOf(stringToRecognizePersonId);
      if (startingIndexOfPersonId >= 0) {
        startingIndexOfPersonId += lengthOfStringToRecognizePersonId;
        var endingIndexOfPersonId = startingIndexOfPersonId + lengthOfPersonId;

        var personId = personFileContent.substring(startingIndexOfPersonId, endingIndexOfPersonId);

        // Replace menu entry parent for affected persons
        if (idsOfPersonsWithSpeakerRoles.includes(personId)) {
          personFileContent = personFileContent.replace(stringToRecognizeMenuEntry, stringToReplaceMenuEntry);
          fs.writeFileSync(pathToPersons + nameOfCurrentPersonFile, personFileContent);
        }
      }
    }
  }
}


/*
  * Builds the static site into the "public" directory using Hugo.
*/
function build() {
  return runShellCommand("hugo");
}
build.description = "Build site into the `public` directory.\nRequires Hugo to be installed!\nFetch content before!";


const cleanAll = series(clean, cleanResetRepository);
cleanAll.description = "Remove all generated files to reset repository state."

const allTasks = series(prerequisites, clean, fetch, postprocess, build);
allTasks.description = "Run all tasks necessary to build the finished product."

export {
  prerequisites,
  clean,
  cleanResetRepository,
  fetch,
  postprocess,
  build,
  cleanAll as cleanAll,
  allTasks as default
}